#| XHXIAIEIN
#| 271028354@qq.com
#| 2021.03.10

msgid ""
msgstr "Content-Type: text/plain; charset=UTF-8"

#: unit1.rsfirststeptoohardbettergiveupnow
msgid "First step too hard? Go to forum.cheatengine.org, then click on \"Tutorials\" for helpful guides!"
msgstr "第一关就太难了？不会吧？\n！"

#: unit1.rstutorial1
msgid ""
"Welcome to the Cheat Engine Tutorial (v3.4)\n"
"\n"
"This tutorial will teach you the basics of cheating in video games. It will also show you foundational aspects of using Cheat Engine (or CE for short). Follow the steps below to get started.\n"
"\n"
"1: Open Cheat Engine if it currently isn't running.\n"
"2: Click on the \"Open Process\" icon (it's the top-left icon with the computer on it, below \"File\".).\n"
"3: With the Process List window now open, look for this tutorial's process in the list. It will look something like \"00001F98-Tutorial-x86_64.exe\" or \"0000047C-Tutorial-i386.exe\". (The first 8 numbers/letters will probably be different.)\n"
"4: Once you've found the process, click on it to select it, then click the \"Open\" button. (Don't worry about all the other buttons right now. You can learn about them later if you're interested.)\n"
"\n"
"Congratulations! If you did everything correctly, the process window should be gone with Cheat Engine now attached to the tutorial (you will see the process name towards the top-center of CE).\n"
"\n"
"Click the \"Next\" button below to continue, or fill in the password and click the \"OK\" button to proceed to that step.)\n"
"\n"
"If you're having problems, simply head over to forum.cheatengine.org, then click on \"Tutorials\" to view beginner-friendly guides!\n"
msgstr ""
"------------------------------------------------------------------\n"
" ( •̀ ω •́ )✧ 欢迎来到 Cheat Engine 新手教程 (v3.4)\n"
"------------------------------------------------------------------\n\n"
"本教程会教你「如何在游戏中作弊」的基本知识。\n"
"既然是个新手菜鸟，先从基本操作开始动手吧。\n"
"\n"
"#1 启动 Cheat Engine 主程序\n"
"如果你还没运行，先将它启动。\n"
"\n"
"\n"
"#2 点击「打开进程」图标\n"
" ▪ 它是工具栏第一个图标，像一个电脑+放大镜。\n"
" ▪ 它位于菜单栏-文件的下方。\n"
" ▪ 如果你是首次启动，可能还能看到它还有个不断闪烁的边框。\n"
"\n"
"\n"
"#3 找到「Tutorial」进程\n"
" ▪ 在进程列表窗口中，将列表拉到底部，找到本教程的进程。\n"
" ▪ 它标题类似 “00001234-Tutorial-x86_64.exe” (前面的八个数字可能会不一样)\n"
"\n"
"\n"
"如果你已经看到了这个进程，选中它，然后点击「打开」按钮。\n（先别管其它按钮，如果你感兴趣，你会在后面接触到它们的）\n"
"\n---\n\n"
"先提前恭喜你！\n如果你全都做对了，进程列表窗口会自动关闭，并且在 Cheat Engine 页面中间顶部的位置看到该进程的名字。\n"
"\n\n"
"现在，你可以点击 “下一步” 按钮来继续学习教程了。如果你知道某个跳关密码，也可以输入它跳转到相应的教学关卡\n"
"\n\n"
"如果你遇到了任何问题，可以到交流论坛 forum.cheatengine.org 教程板块反馈，你还能在论坛中找到更多针对初学者的内容。\n"

#: unit2.rsawyouredeathletmereviveyou
msgctxt "unit2.rsawyouredeathletmereviveyou"
msgid "Aw, you're dead! Let me revive you"
msgstr "嘣，你已经死了！没事，让我复活你"

#: unit2.rsloser
msgctxt "unit2.rsloser"
msgid "BOO"
msgstr "_(:з」∠)_"

#: unit2.rsquittingonstep2thisistheeasieststepthereisfindheal
msgid "Quitting on step2? This is the easiest step there is. Find health, change health, done.... Sure you want to quit?"
msgstr "什么？你要退出第2关？\n嘿！听着，后面没有比这更简单的一关了！你只要搜索数值，打我，再搜索数值，肯定能找到生命值的地址……\n确定要退出吗？"

#: unit2.rsstep2exactvaluescanningpw
msgid "Step 2: Exact Value scanning (PW="
msgstr ""
"------------------------------------------------------------------\n"
"第2关：扫描精确值 (跳关密码="

#: unit2.rstutorialstep2
msgid ""
"Now that you have opened the tutorial with Cheat Engine let's get on with the next step.\n"
"\n"
"You can see at the bottom of this window is the text Health: xxx\n"
"Each time you click 'Hit me'  your health gets decreased.\n"
"\n"
"To get to the next step you have to find this value and change it to 1000\n"
"\n"
"To find the value there are different ways, but I'll tell you about the easiest, 'Exact Value':\n"
"First make sure value type is set to at least 2-bytes or 4-bytes. 1-byte will also work, but you'll run into an easy to fix problem when you've found the address and want to change it. The 8-byte may perhaps works if the bytes after the address are 0, but I wouldn't take the bet.\n"
"Single, double, and the other scans just don't work, because they store the value in a different way.\n"
"\n"
"When the value type is set correctly, make sure the scantype is set to 'Exact Value'\n"
"Then fill in the number your health is in the value box. And click 'First Scan'\n"
"After a while (if you have a extremely slow pc) the scan is done and the results are shown in the list on the left\n"
"\n"
"If you find more than 1 address and you don't know for sure which address it is, click 'Hit me', fill in the new health value into the value box, and click 'Next Scan'\n"
"repeat this until you're sure you've found it. (that includes that there's only 1 address in the list.....)\n"
"\n"
"Now double click the address in the list on the left. This makes the address pop-up in the list at the bottom, showing you the current value.\n"
"Double click the value, (or select it and press enter), and change the value to 1000.\n"
"\n"
"If everything went ok the next button should become enabled, and you're ready for the next step.\n"
"\n"
"\n"
"Note:\n"
"If you did anything wrong while scanning, click \"New Scan\" and repeat the scanning again.\n"
"Also, try playing around with the value and click 'hit me'\n"
msgstr ""
"------------------------------------------------------------------\n\n"
"要正式开始了！这次我们来修改游戏中的血量\n"
"看到窗口底部的生命值了吗？，每次点击 ‹打我› 按钮，生命值就会减少！\n"
"\n"
"\n"
"◆ 过关条件：将 生命值 数值修改为 1000 \n"
"\n"
"\n"
"------------------------------------------------------------------\n\n"
"\n"
"【提示】\n\n"
"尽管有各种不同的方法都能找到生命值的内存地址\n"
"但是我会告诉你最简单的那个方法：\n"
"\n"
" ▪ 首先，将 [扫描类型] 设置为「精确数值」\n"
" ▪ 接着，把 [数值类型] 设置为「4 字节」\n"
" ▪ 然后，在上方的输入框填入当前 生命值 的数值，并点击 ‹首次扫描› \n"
"\n"
"等待扫描完毕，左边的列表会显示扫描结果。你可能会找到非常多的地址，而且你无法确认哪个才是真的。\n"
"\n"
"现在，可以点击 ‹打我› 按钮，让生命值发生变化，然后再次输入新的数值并点击「再次扫描」按钮。这样反复操作几次，直到你确定找到了真正的地址。（或者列表中只剩下一个地址）\n"
"\n"
"双击这个地址，它会出现在窗口下面的列表里，你还能看到它当前的数值，然后双击这个数值，（或者选中并按下回车键），把数值修改成 1000 \n"
"\n"
"\n"
"如果操作正确，“下一步” 按钮就会变成激活的状态。\n"
"恭喜你，过关了！准备好进入下一关吧！\n"
"\n"
"\n"
"------------------------------------------------------------------\n\n"
"【备注】\n"
"如果你在扫描过程中，操作失误。或者填错了数值。可以点击 ‹新的扫描› 重新再试一次。\n"
"\n"
"\n"
"\n"
"\n"
"对了对了，试着多点几次 ‹打我› 玩玩，会上瘾的！ (๐॔˃̶ᗜ˂̶๐॓) \n"

#: unit3.rsdead
msgid "Seems you've done it again! Let me get a replacement! (And restart your scan!)"
msgstr "看来你又调皮了！很好，我再给你换一个血条！（然后重新开始扫描）"

#: unit3.rsloser
msgctxt "unit3.rsloser"
msgid "BOO"
msgstr "_(:з」∠)_"

#: unit3.rsstep3unknowninitialvaluepw
msgid "Step 3: Unknown initial value (PW="
msgstr ""
"------------------------------------------------------------------\n"
"第3关：未知初始值 (跳关密码="

#: unit3.rstryagain3
msgid "Step 3 isn't really that hard. Just do a new scan, unkown initial value and then decreased value till you find it. Almost everyone gets past this one. Sure you want to quit?"
msgstr "等等，别放弃啊！第3关其实并不难！\n扫描一次未知初始值，然后减少数值，再次扫描，反复操作直到找到它。几乎所有人能通过这一关。\n你真的要退出吗？"

#: unit3.rstutorialstep3
msgid ""
"Ok, seeing that you've figured out how to find a value using exact value let's move on to the next step.\n"
"\n"
"First things first though. Since you are doing a new scan, you have to click on New Scan first, to start a new scan. (You may think this is straighforward, but you'd be surprised how many people get stuck on that step) I won't be explaining this step again, so keep this in mind\n"
"Now that you've started a new scan, let's continue\n"
"\n"
"In the previous test we knew the initial value so we could do a exact value, but now we have a status bar where we don't know the starting value.\n"
"We only know that the value is between 0 and 500. And each time you click 'hit me' you lose some health. The amount you lose each time is shown above the status bar.\n"
"\n"
"Again there are several different ways to find the value. (like doing a decreased value by... scan), but I'll only explain the easiest. \"Unknown initial value\", and decreased value.\n"
"Because you don't know the value it is right now, a exact value wont do any good, so choose as scantype 'Unknown initial value', again, the value type is 4-bytes. (most windows apps use 4-bytes)click first scan and wait till it's done.\n"
"\n"
"When it is done click 'hit me'. You'll lose some of your health. (the amount you lost shows for a few seconds and then disappears, but you don't need that)\n"
"Now go to Cheat Engine, and choose 'Decreased Value' and click 'Next Scan'\n"
"When that scan is done, click hit me again, and repeat the above till you only find a few. \n"
"\n"
"We know the value is between 0 and 500, so pick the one that is most likely the address we need, and add it to the list.\n"
"Now change the health to 5000, to proceed to the next step.\n"
msgstr ""
"------------------------------------------------------------------\n\n"
"看来你已经学会怎么利用精确数值查找地址了，这次提高一下难度。上一关，我们是已经知道初始值，所以可以用精确值进行扫描。\n"
"\n"
"但现在窗口底部只有一个「未知初始值」的血条，数值范围在 0 到 500 之间。每次点击 ‹打我› 按钮就会失去一些生命值。并且本次减少的数值会显示在血条上方。\n"
"\n"
"◆ 过关条件：将 生命值 数值修改为 5000 \n"
"\n"
"\n"
"------------------------------------------------------------------\n"
"\n"
"\n"
"【提示】\n\n"
"同样，找到地址的方法也有好几种。例如每次扫描「数值减少了...」的精确值。\n"
"这里我就讲解最简单的方法好了：\n"
"\n"
" ▪ 将 [扫描类型] 设置为「未知初始值」\n"
" ▪ 把 [数值类型] 设置为「4 字节」\n"
" ▪ 点击 ‹首次扫描› \n"
"\n"
"等待扫描完毕，左边列表上方可能提示已经找到了好几十万个地址，但是不要紧。\n"
"\n"
" ▪ 点击 ‹打我› 按钮，减少一些生命值。（损失的数量会显示几秒，然后马上消失）\n"
" ▪ 更换 [扫描类型] 为「减少的数值」 \n"
" ▪ 点击 ‹再次扫描› \n"
"\n"
"这样反复操作几次，直到列表只剩几个地址。\n"
"前面我们已经知道了，数值在 0 到 500 之间。你现在应该能分辨出哪个最有可能是正确的地址了吧？修改它！\n"
"\n"
"\n"
"如果操作正确，“下一步” 按钮就会变成激活的状态。\n"
"恭喜你，又学会了新知识！\n"
"\n"

#: unit5.rsconfirmclose5
msgid "Come on. This step is simple. For health do a float scan, and for ammo a double type. (don't forget to disable fastscan for double in this case) Just ignore the fact that it looks different because it has a \".\" in the value. You sure you want to quit?"
msgstr "加油！其实这一关非常简单！不要放弃啊！\n用单浮点扫描生命值，用双浮点扫描子弹。\n确定要退出吗？"

#: unit5.rsdead
msgid "I think you're dead!%sPress ok to become a brain eating zombie"
msgstr "我想你已经死了！%s按确定变成吃脑子的丧尸"

#: unit5.rsloser
msgctxt "unit5.rsloser"
msgid "BOO"
msgstr "_(:з」∠)_"

#: unit5.rsoutofammo
msgid "Out of ammo!%sPress ok to stock up on some ammo"
msgstr "没子弹了！%s按确认加点子弹"

#: unit5.rsstep4floatingpointspw
msgid "Step 4: Floating points (PW="
msgstr ""
"------------------------------------------------------------------\n"
"第4关：浮点数 (跳关密码="

#: unit5.rstutorialstep4
msgid ""
"In the previous tutorial we used bytes to scan, but some games store information in so called 'floating point' notations. \n"
"(probably to prevent simple memory scanners from finding it the easy way)\n"
"a floating point is a value with some digits behind the point. (like 5.12 or 11321.1)\n"
"\n"
"Below you see your health and ammo. Both are stored as Floating point notations, but health is stored as a float and ammo is stored as a double.\n"
"Click on hit me to lose some health, and on shoot to decrease your ammo with 0.5\n"
" \n"
"You have to set BOTH values to 5000 or higher to proceed.\n"
"\n"
"Exact value scan will work fine here, but you may want to experiment with other types too.\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"Hint: It is recommended to disable \"Fast Scan\" for type double\n"
msgstr ""
"------------------------------------------------------------------\n\n"
"在之前的教程中，我们扫描的数值都是「字节」类型，因为它们都是一个整数。现实还有些游戏使用了「浮点数」进行存储。浮点数，就是带小数点的数值，例如 3.14 或 1234.5678 \n"
"\n"
"这次关卡有 2 个目标数值：生命值和子弹。它们的 [数值类型] 都是浮点数，但生命值是「单浮点」，而子弹是「双浮点」\n"
"\n"
"\n"
"每次点击 ‹打我› 减少一些生命值 ，点击 ‹发射› 减少 0.5 发子弹\n"
"\n"
"\n"
"◆ 过关条件：将两个数值都修改为 5000 或更高。\n"
"\n"
"------------------------------------------------------------------\n\n"
"\n"
"其实这关也没什么好提示的，跟前面的步骤没多大区别。\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"【提示1】\n\n"
"在本关卡「扫描精确数值」也可以很好的工作，但你应该想尝试点不一样的东西吧？\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"【提示2】\n\n"
"在扫描「双浮点」类型的时候，建议禁用「快速扫描」功能。\n"

#: unit6.rsloser
msgctxt "unit6.rsloser"
msgid "BOO"
msgstr "_(:з」∠)_"

#: unit6.rsstep5codefinderpw
msgid "Step 5: Code finder (PW=%s)"
msgstr ""
"------------------------------------------------------------------\n"
"第5关：代码查找 (跳关密码=%s)"

#: unit6.rstryagain6
msgid "This may look difficult. but it's basicly. Find health, rigthclick health, find what writes, change health, click replace, change health, done.  But don't feel down if you don't get it. at least you know the basicas of memory scanning...  Are you sure you want to quit?"
msgstr "这一关确实看起来有些难，但这是必须掌握的基本功。\n先找出生命值地址，右键，找出是什么改写了它，接着点替换就完事了。\n\n实在不知道怎么操作也不要沮丧，没事的，至少你现在已经知道扫描内存的最基本原理了...\n\n确定要退出吗？"

#: unit6.rstutorialstep5
msgid ""
"Sometimes the location of where something is stored at changes when you restart the game, or even while you're playing.. In that case you can use 2 things to still make a table that works.\n"
"In this step I'll try to describe how to use the Code Finder function.\n"
"\n"
"The value down here will be at a different location each time you start the tutorial, so a normal entry in the address list wouldn't work.\n"
"First try to find the address. (you've got to this point so I assume you know how to)\n"
"When you've found the address, right-click the address in Cheat Engine and choose \"Find out what writes to this address\". A window will pop up with an empty list.\n"
"Then click on the Change value button in this tutorial, and go back to Cheat Engine. If everything went right there should be an address with assembler code there now.\n"
"Click it and choose the replace option to replace it with code that does nothing. That will also add the code address to the code list in the advanced options window. (Which gets saved if you save your table)\n"
"\n"
"Click on stop, so the game will start running normal again, and close to close the window.\n"
"Now, click on Change value, and if everything went right the Next button should become enabled.\n"
"\n"
"Note: When you're freezing the address with a high enough speed it may happen that next becomes visible anyhow\n"
msgstr ""
"------------------------------------------------------------------\n\n"
"你是否遇到过这样的情况：有时你重启了游戏，或是在游戏中切换场景，数值内存地址会发生改变。接下来，我会教你如何使用「代码查找」功能，来应对这种情况。\n"
"\n"
"窗口下方的生命值，每次进入教程或者点击按钮，它的内存地址都会存放在不同位置，因此正常修改方法对它是无效的。\n"
"\n"
"\n"
"◆ 过关条件：锁定数值。即使点击 ‹改变数值› 按钮，也不让数值发生更改。\n"
"\n"
"\n"
"------------------------------------------------------------------\n\n"
"\n"
"\n"
"【提示】\n\n"
"我们这一关的目标，是锁定数值。那么只需要将程序指令中关于「写入数值」类型的指令替换掉，防止它更改数值就可以了。\n"
"\n"
"首先，找到数值的地址，然后右键「找出是什么写入这个地址」\n"
"\n"
"再次「改变数值」，窗口列表中会出现一些汇编指令。它们大致上有几种形式：\n"
" ▪ mov [**],**\n"
" ▪ add [**],**\n"
" ▪ sub [**],**\n"
" ▪ *** [**],**\n"
"\n"
"如果你想查看内部汇编程序的指令，则可以双击它，或者选中后点击「更多信息」。\n"
"\n"
"\n"
"\n"
"在列表中找出写入类型的指令： mov [***], ***\n"
"点击右上角的「替换」按钮，它将会把这条指令内容替换为「nop」，也就是空指令。程序读取到它时，将什么也不做。\n"
"\n"
"替换完成后，别忘了点击右下方的「停止」按钮，将进程附加器暂停。\n"
"\n"
"\n"
"\n"
"如果你操作失误，也可以回到 Cheat Engine 窗口左下方进入「高级选项」，找到目前所有修改的代码列表。\n"
"被替换的指令在列表中显示的是红色文本。选中其中一条并右键「还原代码」，将其还原为初始指令，同时文本变成黑色。\n"

#: unit6.rswelldoneyouscrewedupthetutorial
msgctxt "unit6.rswelldoneyouscrewedupthetutorial"
msgid "Well done, you screwed up the tutorial!!!!"
msgstr "很好，做的很好！你成功搞砸了教程！！！！"

#: unit7.rsdontfuckingfreezethepointer
msgid "I'm sorry, but freezing the pointer is not really a functional solution"
msgstr "抱歉，冻结指针不是真正可行的办法"

#: unit7.rsloser
msgctxt "unit7.rsloser"
msgid "BOO"
msgstr "_(:з」∠)_"

#: unit7.rsstep6pointerspw
msgid "Step 6: Pointers: (PW=%s)"
msgstr ""
"------------------------------------------------------------------\n"
"第6关：指针 (跳关密码=%s)"

#: unit7.rstryagain7
msgid "So, pointers are too difficult eh? Don't worry, try again later. For most beginners this is difficult to grasp. But I have to tell you it's a powerful feature if you learn to use it. Are you sure you want to quit?"
msgstr "所以，指针这玩意真的太难了吗？\n\n不要紧，放松一下心情，晚点再尝试。对大多数新手来说，这确实有些难以理解的。但我要告诉你，它是一个非常强大的功能，如果你能学会使用它的话。\n\n确认要退出吗？"

#: unit7.rstutorialstep6
msgid ""
"In the previous step I explained how to use the Code finder to handle changing locations. But that method alone makes it difficult to find the address to set the values you want.\n"
"That's why there are pointers:\n"
"\n"
"At the bottom you'll find 2 buttons. One will change the value, and the other changes the value AND the location of the value.\n"
"For this step you don't really need to know assembler, but it helps a lot if you do.\n"
"\n"
"First find the address of the value. When you've found it use the function to find out what accesses this address.\n"
"Change the value again, and a item will show in the list. Double click that item. (or select and click on more info) and a new window will open with detailed information on what happened when the instruction ran.\n"
"If the assembler instruction doesn't have anything between a '[' and ']' then use another item in the list.\n"
"If it does it will say what it think will be the value of the pointer you need.\n"
"Go back to the main cheat engine window (you can keep this extra info window open if you want, but if you close it, remember what is between the [ and ] ) and do a 4 byte scan in hexadecimal for the value the extra info told you.\n"
"When done scanning it may return 1 or a few hundred addresses. Most of the time the address you need will be the smallest one. Now click on manually add and select the pointer checkbox.\n"
"\n"
"The window will change and allow you to type in the address of a pointer and a offset.\n"
"Fill in as address the address you just found.\n"
"If the assembler instruction has a calculation (e.g: [esi+12]) at the end then type the value in that's at the end. else leave it 0. If it was a more complicated instruction look at the calculation.\n"
"\n"
"example of a more complicated instruction:\n"
"[EAX*2+EDX+00000310] eax=4C and edx=00801234.\n"
"In this case EDX would be the value the pointer has, and EAX*2+00000310 the offset, so the offset you'd fill in would be 2*4C+00000310=3A8.  (this is all in hex, use calc.exe from windows in scientific mode to calculate)\n"
"\n"
"Back to the tutorial, click OK and the address will be added, If all went right the address will show P->xxxxxxx, with xxxxxxx being the address of the value you found. If thats not right, you've done something wrong.\n"
"Now, change the value using the pointer you added in 5000 and freeze it. Then click Change pointer, and if all went \n"
"right the next button will become visible.\n"
"\n"
"\n"
"extra:\n"
"And you could also use the pointer scanner to find the pointer to this address\n"
msgstr ""
"------------------------------------------------------------------\n\n"
"前面解释了怎么使用「代码查找」处理会变化的地址，但是在一些具有更高级防加密技术的游戏中，如果你只会用那个方法，其实很难找到实际要修改的数值地址。\n"
"\n"
"所以，这就是为什么还需要学习「指针」的原因。这一关你不需要懂汇编的知识，当然如果你稍微懂一点会有很大的帮助。\n"
"\n"
"现在窗口下面有两个按钮，一个改变数值，另一个改变数值的同时改变内存地址的指针\n"
"\n"
"\n"
"◆ 过关条件：将生命值锁定为 5000。即使点击 ‹改变指针› 按钮，数值也不会变化。\n"
"\n"
"\n"
"------------------------------------------------------------------\n\n"
"\n"
"【提示】\n\n"
"首先，找到数值地址，然后右键「找出是什么写入这个地址」接着再次「改变数值」，窗口列表中会出现一条汇编指令，双击它，或者选中后点击「更多信息」\n"
"\n"
"\n"
"接着会弹出一个新窗口，这里主要找汇编指令中 [ ] 之间的部分，这就是我们要找的指针。\n"
"如果你看到 [ ] 之间没有任何东西，那么跳过它，使用列表中其他的地址。\n"
"\n"
"\n"
"你可能注意到了，下方有一行提示：「要查找的这个地址的指针数值可能是 xxx」\n"
"感谢这个贴心小功能，你等会就不需要手动输入地址了，只需要右键，将简单猜测复制到剪贴板。 \n"
"\n"
"\n"
"回到 Cheat Engine 主窗口，进行新的扫描。这次勾选「十六进制数值」单选框，并使用「4字节」扫描刚才那个十六进制数值。\n"
"\n"
"扫描完成后它可能返回一个或几十个地址，多数时候你需要的地址是最小的那个地址。\n"
"\n"
"接着，点击「手动添加地址」并勾选底部的「指针」选项，在新的输入框里输入刚才找到的指针地址，添加后，此条记录的地址是「 P->XXXXX」其中的 xxx 就是你找到的指针数值地址。 \n"
"\n"
"如果指针地址没选错，数值应该是和教程窗口的数值是相同的。如果数值不相同，说明你地址选错了，尝试回到额外信息窗口的汇编指令列表，选择另一个地址。\n"
"\n"
"\n"
"现在，只需要像往常一样，编辑数值为 5000，并勾选左边的锁定数值。然后点击「改变指针」按钮，下一步的按钮就能被激活了~\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"【补充】\n"
"在手动添加地址步骤中，如果汇编指令包含复杂的计算公式，则需要手动计算偏移值。\n"
"\n"
"简单例子：\n"
"mov [edx+12C],eax \n"
"那么，偏移值应该为 12C (0x12C)。注意，这里的偏移值都是十六进制的单位表示。\n"
"\n"
"\n"
"更复杂指令的例子：\n"
"[EAX*2+EDX+00000310] \n"
"EAX=4C\n"
"EDX=00801234\n"
"\n"
"这种情况下，我们拆开来分析：\n"
"「EDX」是数值的指针，「EAX*2+00000310」是偏移值。\n"
"\n"
"将数值代入到计算公式中，变成：\n"
" ▪ ->「4C*2 + 00000310」\n"
" ▪ ->「98 + 00000310」\n"
" ▪ ->「98 + 310」\n"
" ▪ ->「3A8」\n"
"\n"
"因此，偏移值是「3A8」\n"
"\n"
"\n"
"还是要提醒下，这里都是以十六进制来计算，而非十进制。\n"
"你可以用系统自带计算器并切换到科学计算器。以 HEX 方式计算出结果。\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"------------------------------------------------------------------\n"
"\n"
"如果这关实在不知道如何操作，可以访问 wiki 页面查看图文教程：\n"
"https://wiki.cheatengine.org/index.php?title=Tutorials:Cheat_Engine_Tutorial_Guide_x32#Step_6\n"
"\n"

#: unit7.rswelldoneyouscrewedupthetutorial
msgctxt "unit7.rswelldoneyouscrewedupthetutorial"
msgid "Well done, you screwed up the tutorial!!!!"
msgstr "做得好，你搞砸了这个教程！！！"

#: unit7.rsyouvegotsecondslefttochangethevalueto5000
msgid "You have %s second%s left to change the value to 5000"
msgstr "你还有 %s 秒时间改变数值为5000"

#: unit8.rsawyouredeathletmereviveyou
msgctxt "unit8.rsawyouredeathletmereviveyou"
msgid "Aw, you're dead! Let me revive you"
msgstr "噢，你死了，让我复活你"

#: unit8.rshealth
msgid "Health"
msgstr "生命值 "

#: unit8.rsloser
msgctxt "unit8.rsloser"
msgid "BOO"
msgstr "_(:з」∠)_"

#: unit8.rsstep7codeinjectionpw
msgid "Step 7: Code Injection: (PW=%s)"
msgstr ""
"------------------------------------------------------------------\n"
"第7关：代码注入 (跳关密码=%s)"

#: unit8.rstryagain8
msgid "Code injections too tough? No problem, memory scanning and basic pointers should be enough to get you experienced enough and you can always try the tutorial later. Are you sure you want to quit?"
msgstr "代码注入太难了？没关系的，下次再试。\n内存扫描和基本指针这些功能需要你有足够的编程经验才能理解，以后再回来继续挑战吧。\n\n确认要退出吗？"

#: unit8.rstutorialstep7
msgid ""
"Code injection is a technique where you inject a piece of code into the target process, and then reroute the execution of code to go through your own written code.\n"
"\n"
"In this tutorial you'll have a health value and a button that will decrease your health by 1 each time you click it.\n"
"Your task is to use code injection to make the button increase your health by 2 each time it is clicked\n"
"\n"
"Start with finding the address and then find what writes to it.\n"
"then when you've found the code that decreases it browse to that address in the disassembler, and open the auto assembler window (ctrl+a)\n"
"There click on template and then code injection, and give it the address that decreases health (If it isn't already filled in correctly)\n"
"That will generate a basic auto assembler injection framework you can use for your code.\n"
"\n"
"Notice the alloc, that will allocate a block of memory for your code cave, in the past, in the pre windows 2000 systems, people had to find code caves in the memory(regions of memory unused by the game), but that's luckily a thing of the past since windows 2000, and will these days cause errors when trying to be used, due to SP2 of XP and the NX bit of new CPU's\n"
"\n"
"Also notice the line newmem: and originalcode: and the text \"Place your code here\"\n"
"As you guessed it, write your code here that will increase the  health with 2.\n"
"An usefull assembler instruction in this case is the \"ADD instruction\"\n"
"here are a few examples:\n"
"\"ADD [00901234],9\" to increase the address at 00901234 with 9\n"
"\"ADD [ESP+4],9\" to increase the address pointed to by ESP+4 with 9\n"
"In this case, you'll have to use the same thing between the brackets as the original code has that decreases your health\n"
"\n"
"Notice:\n"
"It is recommended to delete the line that decreases your health from the original code section, else you'll have to increase your health with 3 (you increase with 3, the original code decreases with 1, so the end result is increase with 2), which might become confusing. But it's all up to you and your programming.\n"
"\n"
"Notice 2:\n"
"In some games the original code can exist out of multiple instructions, and sometimes, not always, it might happen that a code at another place jumps into your jump instruction end will then cause unknown behavior. If that happens, you should usually look near that instruction and see the jumps and fix it, or perhaps even choose to use a different address to do the code injection from. As long as you're able to figure out the address to change from inside your injected code.\n"
msgstr ""
"------------------------------------------------------------------\n\n"
"代码注入是个技术活，你要把一段汇编代码注入到目标进程，让程序执行你的代码。\n"
"\n"
"\n"
"在这个教程，你有一个「生命值」 ，以及每按1次就减少1点生命的「打我」按钮。\n"
"\n"
"\n"
"◆ 过关条件：注入代码，将「打我」按钮的效果变成每次增加 2 点生命值。\n"
"\n"
"\n"
"------------------------------------------------------------------\n"
"\n"
"\n"
"【提示】\n\n"
"和前面第5关操作一样，先找到地址，然后查看谁改写了它。\n"
"\n"
"但是，这里要做的不是“替换”，而是「显示反汇编程序」\n"
"你会看到这行汇编指令大致是这样的：sub dword ptr [ebx+xxxx],01\n"
"\n"
"\n"
"在内存浏览器窗口找到这行汇编指令，然后打开「自动汇编窗口（Ctrl+A）」\n"
"或者通过「菜单栏 - 工具 - 自动汇编」找到它，就在列表最底部。\n"
"\n"
"\n"
"在自动汇编窗口点击「模板」，选择代码注入。\n"
"提示需要输入跳转地址，这里会给你自动输入跳转的地址，直接点击确定即可。如果它没有自动填入，那你可能要自己输入地址。\n"
"\n"
"\n"
"接着窗口中会生成一段自动汇编注入的基本代码框架，方便你快速修改。\n"
"\n"
"\n"
"注意，把你的代码写在蓝色注释 “place your code here” 的下方。\n"
"\n"
"\n"
"先来分析一下原代码的汇编指令：\n"
"sub dword ptr [ebx+xxxx], 01\n"
"\n"
"\n"
"sub 是减法指令。sub a,b，也就是变成 a - b\n"
"这里的意思就是每次将数值减去 1\n"
"\n"
"那么是不是把减法改成加法，就可以了呢？\n"
"\n"
"没错，加法的汇编指令是：ADD\n"
"\n"
"使用例子：\n"
"ADD [00901234],9   —— 将 00901234 地址的数值加 9\n"
"ADD [ESP+4],9      —— 将 ESP+4 指针指向的地址的数值增加 9\n"
"\n"
"\n"
"那么，现在就有很多种方法可以过关了。\n"
"例如直接修改 originalcode 源代码部分，把减少生命值的代码修改。\n"
" ▪ 注释原来的代码，直接替换成增加 2 点生命值？( 0 + 2)\n"
" ▪ 保留原来的代码，在后面补充增加 3 点生命值？(-1 + 3)\n"
"\n"
"反正办法有很多，你自己决定了。\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"【补充】\n\n"
"在某些游戏里，原代码可能位于多条指令的跳转之外。这种情况偶尔会发生，但不一定总是这样。\n"
"它可能导致其它地方的一段代码跳转到你的代码后面，导致出现未知的行为。\n"
"\n"
"如果这样，你通常要看看附近是否存在跳转指令来修正它。或者可能要选另一个地址来注入代码，只要你能从你的注入代码里找到要改变的地址。\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"------------------------------------------------------------------\n"
"\n"
"如果这关实在不知道如何操作，可以访问 wiki 页面查看图文教程：\n"
"https://wiki.cheatengine.org/index.php?title=Tutorials:Cheat_Engine_Tutorial_Guide_x32#Step_7\n"
"\n"

#: unit9.rsloser
msgctxt "unit9.rsloser"
msgid "BOO"
msgstr "_(:з」∠)_"

#: unit9.rsstep8multilevelpointerspw
msgid "Step 8: Multilevel pointers: (PW=%s)"
msgstr ""
"------------------------------------------------------------------\n"
"第8关：多级指针 (跳关密码=%s)"

#: unit9.rstryagain9
msgid "Aw, you've almost reached the end. But don't worry, multilevel pointers can be a real pain when dealing with. If you get more experienced someday you can try it again. Are you sure you want to quit?"
msgstr "噢，你就快结束教程了，但没关系，多级指针真的很难学，等哪天你想起再来吧。确认退出？"

#: unit9.rstutorialstep8
msgid ""
"This step will explain how to use multi-level pointers.\n"
"In step 6 you had a simple level-1 pointer, with the first address found already being the real base address.\n"
"This step however is a level-4 pointer. It has a pointer to a pointer to a pointer to a pointer to a pointer to the health.\n"
"\n"
"You basicly do the same as in step 6. Find out what accesses the value, look at the instruction and what probably is the base pointer value, and what is the offset, and already fill that in or write it down. But in this case the address you'll find will also be a pointer. You just have to find out the pointer to that pointer exactly the same way as you did with the value. Find out what accesses that address you found, look at the assembler instruction, note the probable instruction and offset, and use that.\n"
"and continue till you can't get any further (usually when the base address is a static address, shown up as green)\n"
"\n"
"Click Change Value to let the tutorial access the health.\n"
"If you think you've found the pointer path click Change Register. The pointers and value will then change and you'll have 3 seconds to freeze the address to 5000\n"
"\n"
"Extra: This problem can also be solved using a auto assembler script, or using the pointer scanner\n"
"Extra2: In some situations it is recommended to change ce's codefinder settings to Access violations when \n"
"Encountering instructions like mov eax,[eax] since debugregisters show it AFTER it was changed, making it hard to find out the the value of the